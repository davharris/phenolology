---
title: "A multilevel Bayesian model of pollination phenology in lodgepole pine"
author: "Susannah Tysor"
date: "April 14, 2019"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE)
```
```{r depends}
library(rethinking)
library(dplyr)
library(bayesplot)
library(tidyr)
library(summarytools)

```

```{r stan setup}
util <- new.env()
source('~/Documents/classes/STANworkshop/material/1 - workflow/stan_utility.R', local=util)

options(mc.cores=parallel::detectCores())
rstan_options(auto_write=TRUE)
```

```{r data, echo=FALSE}
phenology_data <- read.csv("../data/stan_input/phenology_heatsum.csv", stringsAsFactors = FALSE, header = TRUE) %>%
    filter(daily_forcing_type=="ristos")

#SPU_dat <- read.csv("~/Documents/research_phd/data/OrchardInfo/LodgepoleSPUs.csv", header=TRUE, stringsAsFactors = FALSE) %>%
 #   dplyr::select(SPU_Name, Orchard)
SPU_dat <- read.csv("~/Documents/research_phd/data/OrchardInfo/LodgepoleSPUs.csv", header=TRUE, stringsAsFactors = FALSE) %>%
  dplyr::select(SPU_Name, Orchard) #add provenance information

phendf <- phenology_data %>%
    na.omit()
phendf <- dplyr::left_join(phenology_data, SPU_dat) %>%
    unique()

view(dfSummary(phendf))
```

```{r stanindexing}
#Create indexes that stan will like
#Create Clone IDs
phendf$CloneID <- group_indices(phendf, Clone)
#Create OrchardIDs
phendf$OrchardID <- group_indices(phendf, Orchard)
#Create ProvenanceIDs
phendf$ProvenanceID <- group_indices(phendf, SPU_Name)
#Create SiteIDs
phendf$SiteID <- group_indices(phendf, Site)
#Create SexIDs
phendf$SexID <- group_indices(phendf, Sex)
#Create TreeIDs
phendf$TreeID_new <- group_indices(phendf, TreeID)
#Create YearIDs
phendf$YearID <- group_indices(phendf, Year)

phen <- phendf #make a copy that will let me translate between ids and values
phen$Phenophase_Derived <- as.factor(phen$Phenophase_Derived)

#drop "non-numeric" cols to make stan quit complaining
phendf <- dplyr::select(phendf, -Site, -SPU_Name, -Sex, -TreeID, -Phenophase, -Date, -Clone, -TreeID_new, -daily_forcing_type)

```
## Conceptual Analysis

Pollination phenology in lodgepole pine refers to the timing of two events - pollen shed and cone receptivity. I want to estimate the beginning, end, and length of both events. 

### Phenology data summary

Pollen shed almost always begins prior to or simultaneously with cone receptivity. Pollen shed finishes before the receptive period is over less than half the time and sometimes finishes after the receptivity period is done. 

```{r dataviz, fig.width=11, fig.height=9}
ggplot(phen, aes(x=forcing_accum, color=Phenophase_Derived, linetype=Sex)) +
    stat_ecdf() +
    theme_bw(base_size=16) +
    facet_grid(SPU_Name ~ Site) +
    scale_color_viridis_d(direction =-1) +
    ggtitle("Phenophase accumulation as heatsum increases\n by Site and Provenance") +
    theme(legend.position = "bottom")

# ggplot(phen, aes(x=forcing_accum, color=Phenophase_Derived)) +
#     geom_density() +
#     theme_bw(base_size=16) +
#     facet_grid(Site ~ SPU_Name, scales="free_y") +
#     scale_color_viridis_d(direction=-1) +
#     ggtitle("Phenophase proportion as heatsum increases\n by Site and Provenance")
# 
# ggplot(phen, aes(x=forcing_accum, color=Phenophase_Derived)) +
#     geom_density() +
#     theme_bw(base_size=16) +
#     facet_grid(SPU_Name ~ Site, scales="free_y") +
#     scale_color_viridis_d(direction=-1) +
#     ggtitle("Phenophase proportion as heatsum increases\n by Site and Provenance")
```

The order of development and the forcing accumulation required is much more consistent across sites than provenances, suggesting stronger site than provenance effects. The proportion of each phenophase at different forcing amounts is much more consistent within a site than within provenances, suggesting strong site effects/limited provenance effects.

![Site x Provenance](../graphsforsally/phenophase_prop_sitexprov.png)
![Provenance x Site](../graphsforsally/phenophase_prop_provxsite.png)


As the developmental process for pollen shed and cone receptivity appears to be logistic (Sarvas 1972), I will use a logistic model. A logistic model has two parameters. $k$ affects the speed of transition and $h$ determines the time ("location") of transition. $k$ must be positive and between 0 and 1. $k$ near 0 is a slow transition. $k$ near one is a near instantaneous transition. $h$ is the inflection point of the curve, in our case, the point at which a given tree is 50% likely to have transitioned from state $s$ to state $s+1$

$$y = \frac{1}{1+e^{-k(x-h)}}$$

There are two transitions I need to model for each event - 
1) transitioning from not started to active and 
2) from active to completed. 

Since there are two transitions, I will use an ordered logistic model that describes the likelihood of being in each phenological state $s$ given a linear model $\eta$ and cutpoints $c$.

For $S=3$ categories

$$\small{\text{OrderedLogistic}(s|~\eta,c) = \left\{ \begin{array}{ll} 1 -
\text{logistic}(\eta - c_1)  &  \text{if } s = 1, \\[4pt]
\text{logistic}(\eta - c_1) - \text{logistic}(\eta - c_2)  &
\text{if } s=2, \text{and} \\[4pt] \text{logistic}(\eta -
c_3) - 0  &  \text{if } s = 3. \end{array} \right.}
$$
Where $\eta$ is a linear model with explanatory variable x - in our case, forcing units (*e.g.* heatsum), and $k$ slope
$$\eta = k x \\$$
This model is parameterized slightly differently than the logistic model above. In this model 

$$k=k \\
h_s=\frac{c_s}{k}\\$$

An ordered logistic model respects the ordering of the phenological states and generates two curves - one representing the "not-yet to active" transition and the other the "active to complete" transition. The transition from before not-yet to not-yet is not meaningful and $c_1$ is set to 0.

Adding compoents to $\eta$ is like adding them to the cutpoints. For example, adding a provenance effect to eta 

$$\eta=kx + \alpha_{provenance}$$
means that the location $h_s$ is calculated as

$$h_s = \frac{c_s+\alpha_{provenance}}{k}$$

In this parameterization, cutpoints are not sex or population specific. $\alpha$ components in $\eta$ affect both transitions equally. So a provenance effect $\alpha_{provenance}$ will shift both the transition from state from 1 to 2 and from 2 to 3 by the same amount. Is this (biologically) correct?

Sarvas's experimental work on development in trees says that 

> the regression of the rate of progress of the active period on temperature is the same for all the genera, species, individual trees and the different parts of the active period investigated in this study. [@Sarvas1972]

His study included *Populus*, *Betula*, *Alnus* as well as *Picea abies*, *Pinus sylvestris*, and 2 *Larix* species.

The unit for the "rate of progress" is period units/hour where period units are 1/5 of the cycle interval that the active period of a given genotype progresses in 1 hour at a constant temperature of 10 degrees C.

So if it takes 100 hours to go from phenophase 1 to 2 at 10 degrees, then the period unit is 20 minutes.

This does not mean that everything should have the same slope ($k$). It does mean that I can use the same forcing units for everything.

I could parameterize the model differently I think. For example, considering just the effects of sex and provenance: 

$$\eta = (k + k_{sex} + k_{provenance})x \\
c_1 = \alpha + \alpha_{sex} + \alpha_{provenance} \\
c_2 = \beta + \beta_{sex} + \beta_{provenance}
$$
This means making way more priors, but I think makes biological sense! In earlier iterations of the model, I've been forcing $h_s$ to have all the same components - except for the primary $\alpha$ and $\beta$. 
In old versions of my model, whatever other effects there are from provenance, clone, ramet, etc shift all $h_s$ by the same amount. 

I am concerned that the model as structured could become non-identifiable. I also think I need to deal with correlations between parameters using cholesky and/or LR things.

### How to include effects of sex, provenance, etc.
The first question is whether to include the effect in the speed of transition $k$ or the locations.

### Male and female in same model?
I am not sure whether to include male and female strobili in the same model. Male and female strobili develop separately but as as part of the same elongating stem. 

If I include them in the same model, unless I do some really crazy parameterization, then I am assuming that clonal, provenance, tree, and site effects are the same across sexes. For example, a clone that has a lower threshold has a lower threshold for both males and females. 

I could do a test for this by running separate models or adding *a lot* of parameters.

The location must vary by sex. If there isn't a cutpoint component  for sex, then curves will be identical for males and females unless the $k$ is allowed to vary. Since $h_s$ depends on $k$ as well as the cutpoints, changes in $k$ can shift the location of the curve. 

Previous model runs have been letting $k$ vary by sex, but not the location. I believe that was a mistake. They could very easily have different $k$ and $h_s$

### Should the sex component have partial pooling?
No! Sex components should not be pooled across males and females. They're connected but separate and I believe they should be allowed to vary completely independently.

## What about pooling for other effects?
For clone, site, and provenance, I believe partial pooling is the right decision. No pooling will overfit and exaggerate effects, but ignoring the effects (total pooling) will ignore effects I'm testing for (provenance) or that undoubtedly exist (clone, site).

Can I explain why I don't think the sex component will be overfit?

## So what should the model look like?

$$\begin{array}{rlr}
S & \sim \text{OrderedLogistic}(s |\eta, c_s)\\
\eta & = k \times f \\
c_1 &= \alpha + \alpha_{sex} + \alpha_{provenance} + \alpha_{site} + \alpha_{clone} + \alpha_{ramet} \\
c_2 &= \beta + \beta_{sex} + \beta_{provenance} + \beta_{site} + \beta_{clone} + \beta_{ramet} \\

&& \text{priors} \\
k &\sim \text{beta}(.5,5) & \text{slope}\\
\\
\alpha &\sim \text{normal}(10, 5) \\
\alpha_{sex} &\sim \text{normal}(0, \sigma_{sex})\\
\alpha_{provenance} &\sim \text{normal}(0, \sigma_{provenance}) \\
\alpha_{site} &\sim \text{normal}(0, \sigma_{site}) \\
\alpha_{clone} &\sim \text{normal}(0, \sigma_{clone}) \\
\alpha_{tree} &\sim \text{normal}(0, \sigma_{tree}) \\
\\
\beta &\sim \text{normal}(20,5) \\
\beta_{sex} &\sim \text{normal}(0, \upsilon_{sex}) \\
\beta_{provenance} &\sim \text{normal}(0, \upsilon_{provenance}) \\
\beta_{site} &\sim \text{normal}(0, \upsilon_{site}) \\
\beta_{clone} &\sim \text{normal}(0, \upsilon_{clone}) \\
\beta_{tree} &\sim \text{normal}(0, \upsilon_{tree}) \\

&& \text{hyperpriors}\\
\sigma_{sex} & \sim \text{exponential}(1.5) \\
\upsilon_{sex} &\sim \text{exponential}(1.5) \\
\\
\sigma_{provenance} &\sim \text{exponential}(1.5) \\
\upsilon_{provenance} &\sim \text{exponential}(1.5) \\
\\
\sigma_{site} &\sim \text{exponential}(1.5) \\
\upsilon_{site} &\sim \text{exponential}(1.5) \\
\\
\sigma_{clone} &\sim \text{exponential}(1.5) \\
\upsilon_{clone} &\sim \text{exponential}(1.5) \\
\\
\sigma_{ramet} &\sim \text{exponential}(1.5) \\
\upsilon_{ramet} &\sim \text{exponential}(1.5)
\end{array}$$


$f$ accumulated forcing units

## What about calculating the start, end, and length of the phenological period?

## Woah now let's calm down and do a simpler version. Maybe look back at an old workflow and try again.

## Fit a model to simulated data

Simulate data from an ordered logistic distribution with three states and forcing values from real data. 

```{r simulate simplest data}
cuts <- c(15,20)
beta <- 0.05
forcing <- runif(300, 175, 500)
eta <- beta * forcing 
state <- rordlogit(length(eta), phi = eta, a = cuts)
sim <- data.frame(forcing,state)
#sim$state <- group_indices(sim, state)
```

7 sites, 6 provenances, and 10 observations for each of 15 individuals at different forcing temperatures
```{r simulate_grouped_data}
# cutpoints <- c(0)
# cutpoints[2] <- abs(rnorm(1,5,2))
# cutpoints[3] <- abs(rnorm(1,20,2))
# #k <- rbeta(1,.5, 5)

nsite <- 7
nprov <- 6
nindiv <- 15
nobs <- 3
forcing <- runif(10, 175,500)
basecut <- c(15,20)
beta = 0.05
cut_site <- rnorm(n= nsite, mean=1, sd=1)
cut_prov <- rnorm(n= nprov, mean=-2, sd=1)

sites <- data.frame(site = 1:nsite, effect = cut_site)
provs <- data.frame(prov = 1:nprov, effect= cut_prov)

simu_prep <- tidyr::crossing(site = sites$site, prov = provs$prov, nobs, indiv = 1:nindiv, forcing) %>%
    dplyr::left_join(sites) %>% #add site and prov effects
    rename(site_effect = effect) %>%
    left_join(provs) %>%
    rename(prov_effect = effect) %>%
    mutate(group_effects = site_effect + prov_effect) 

simu <- simu_prep %>% # calculate cutpoints and eta
    # cutpoints
    mutate(cut1 = group_effects + basecut[1])  %>%
    mutate(cut2 = group_effects + basecut[2]) %>%
    # linear model eta
    mutate(eta = beta * forcing) 

#simulate states
for (i in 1:nrow(simu)) {
    simu$state[i] <- rordlogit(1, 
                               phi = simu$eta[i], 
                               a = c(simu$cut1[i], simu$cut2[i]))
    }
```

```{r visualize simulated_data}
hist(simu$state)
ggplot(simu, aes(x=forcing, y=state, color=prov)) +
    geom_jitter() +
    facet_wrap("site")
```

## Fit model to simulated data

```{r simulated fit}
#Use ulam to help draft the model
# sim <- select(sim, state, forcing)
# simfit <- ulam(
#     alist(
#         #likelihood
#         state ~ dordlogit(eta, cutpoints),
#         # model
#         eta <- beta * forcing,
#         cutpoints <- c(c1, c2),
#         c1 ~ half_normal(5, 3),
#         c2 ~ half_normal(20, 5),
#         # priors
#         beta ~ dbeta(.5,5)
#     ),
#     data=sim, chains=1, cores=1, iter=20
# )

# stancode(simfit)

# Write simulated data in a format stan can understand
# simplest data
K = length(unique(sim$state))
N = nrow(sim)
stan_rdump(c("N", "K", "forcing", "state"), "simulated_nogroups.Rdump")
simplesimdat <- read_rdump("simulated_nogroups.Rdump")

# 1 group data
K <- length(unique(sim$state))
N <- nrow(sim)
Ngroup = length(unique(sim$group))
stan_rdump(c("N", "K", "Ngroup", "forcing", "state", "group"), "simulated_data.Rdump")
simdat <- read_rdump("simulated_data.Rdump")

# Fit model to simulated data
simfit <- stan("cutpoints_difference.stan", 
               chains=5, cores=5, iter=2000, 
               data=simplesimdat)
              #control=list(adapt_delta=0.99))#, max_treedepth=11))

# Check diagnostics
util$check_all_diagnostics(simfit)
```

### Consider fit of model to simulated data
```{r precis simulated data fit}
precis(simfit, depth=2)
```

```{r extract fit}
simpost <- as.matrix(simfit)
pairs(simpost)
```


```{r plot real params vs posterior}
mcmc_areas(simpost, regex_pars = "cutpoints") + 
    geom_vline(xintercept = c(15,20))
mcmc_areas(simpost, pars="beta") +
    geom_vline(xintercept = 0.05)
```

If cutpoints prior is a single gamma distribution, cutpoints are not returned well. Neither is beta. Edited model so prior is on the difference between cutpoints rather than the cutpoints as a group. 

Also want to try 
- modeling cutpoints with separate linear models
- 

## Real data
```{r data}
N <- nrow(phendf)
K <- length(unique(phendf$Phenophase_Derived))
Nsex <- length(unique(phendf$SexID))
Nclone <- length(unique(phendf$CloneID))
Nprovenance <- length(unique(phendf$ProvenanceID))
Nsite <- length(unique(phendf$SiteID))

SexID <- phendf$SexID
OrchardID <- phendf$OrchardID
SiteID <- phendf$SiteID
CloneID <- phendf$CloneID
ProvenanceID <- phendf$ProvenanceID

forcing <- phendf$forcing_accum
state <- phendf$Phenophase_Derived

L <- 1

stan_rdump(c("N", "K", "L", "Nsex", "Nclone", "Nprovenance", "Nsite", "SexID", "SiteID", "CloneID", "ProvenanceID", "forcing", "state"), "multilevel_phenology.Rdump")
standat <- read_rdump("multilevel_phenology.Rdump")
```

```{r fit model}


fit <- stan("multilevel_phenology.stan", 
               chains=5, cores=5, iter=3000, data=standat)


```

```{r save model}
saveRDS(fit, file = "multilevel_phenology.rds")
posterior_cp <- as.array(fit)
```

### Model version with correlation

```{r dataprep}
head(phendf)
```
```{r ulam version sex only no corr}


draft <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- b[SexID] * forcing_accum + a_sex[SexID],
        #c(a_sex, b_sex)[SexID] ~ multi_normal(c(a_sex, b_sex), Rho, sigma_sex),
        a_sex[SexID] ~ dnorm(0,1),
        b[SexID] ~ dbeta(.5,5),
        #sigma_sex ~ exponential(1),
        kappa ~ dnorm(10,2)
       # Rho ~ lkj_corr(2)
    ),
    data=phendf, cores=1, chains=1, iter = 10
)
```

``` {r ulam version sex with corr}


m14.1 <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- a_sex[SexID] + b_sex[SexID]*forcing_accum,
        c(a_sex,b_sex)[SexID] ~ multi_normal( c(a,b) , Rho , sigma_sex ),
        a ~ normal(5,2),
        b ~ normal(-1,0.5),
        sigma_cafe ~ exponential(1),
        sigma ~ exponential(1),
        Rho ~ lkj_corr(2)
    ) , data=d , sample=FALSE )

sexonly <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- a_sex[SexID] + b_sex[SexID]*forcing_accum,
        c(a_sex, b_sex)[SexID] ~ multi_normal(c(a, b), Rho, sigma_sex),
        a ~ dnorm(0,1),
        b ~ dbeta(.5,5),
        sigma_sex ~ exponential(1),
        kappa ~ dnorm(10,2),
        Rho ~ lkj_corr(2)
    ),
    data=phendf, sample=FALSE, declare_all_data= FALSE, iter = 10
)
stancode(draft)

```

```{r sex and prov with corr}
#generate stan code for a draft of the stan code
fit_full_draft <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- alphas + beta*forcing_accum,
        alphas <- a_sex[SexID] + a_site[SiteID] + a_prov[ProvenanceID] + a_clone[CloneID] + a_year[YearID],
        beta <- b + b_sex[SexID] + b_prov[ProvenanceID],
        #priors
        b ~ dbeta(.5,5),
        kappa ~ dnorm(10,2),
        a_site[SiteID] ~ dnorm(0,1),
        a_clone[CloneID] ~ dnorm(0,1),
        a_year[YearID] ~ dnorm(0,1),
        #sex
        c(a_sex, b_sex)[SexID] ~ multi_normal(c(as, bs), Rhos, sigma_sex),
        as ~ dnorm(0,1),
        bs ~ dnorm(0, 0.1),
        sigma_sex ~ exponential(1),
        #provenance
        c(a_prov, b_prov)[ProvenanceID] ~ multi_normal(c(ap, bp), Rhop, sigma_prov),
        ap ~ dnorm(0,1),
        bp ~ dnorm(0, 0.1),
        sigma_prov ~ exponential(1),
        Rhos ~ lkj_corr(2),
        Rhop ~ lkj_corr(2)
    ),
    data=phendf, sample=FALSE, declare_all_data= FALSE, iter = 10
)
stancode(fit_full_draft)
```

```{r fit full model}
fitful <- stan("correlation.stan", 
               chains=1, cores=, iter=20, 
               data=phendf)
```

```{r error diag}
library(rethinking)
data(Trolley)
d <- Trolley

dat <- list(
    R = d$response,
    A = d$action,
    I = d$intention,
    C = d$contact )
m12.6 <- ulam(
    alist(
        R ~ dordlogit( phi , cutpoints ),
        phi <- bA*A + bC*C + BI*I ,
        BI <- bI + bIA*A + bIC*C ,
        c(bA,bI,bC,bIA,bIC) ~ dnorm( 0 , 0.5 ),
        cutpoints ~ dnorm( 0 , 1.5 )
    ) , data=dat , chains=1 , cores=1, iter=10 )
precis( m12.6 )
```
```