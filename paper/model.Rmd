---
title: "A multilevel Bayesian model of pollination phenology in lodgepole pine"
author: "Susannah Tysor"
date: "April 16, 2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE)
```

```{r depends}
library(rethinking)
library(dplyr)
library(bayesplot)
library(tidyr)
library(summarytools)

```

```{r stan setup}
util <- new.env()
source('~/Documents/classes/STANworkshop/material/1 - workflow/stan_utility.R', local=util)

options(mc.cores=parallel::detectCores())
rstan_options(auto_write=TRUE)
```

## Conceptual Analysis

Pollination phenology in lodgepole pine refers to the timing of two events - pollen shed and cone receptivity. I want to estimate the beginning, end, and length of both events. 

### Phenology data summary

```{r data, echo=FALSE, results="asis"}

# phenology_data <- read.csv("data/stan_input/phenology_heatsum.csv", stringsAsFactors = FALSE, header = TRUE) %>%
#     filter(daily_forcing_type=="ristos")
phenology_data <- read.csv("../data/stan_input/phenology_heatsum.csv", stringsAsFactors = FALSE, header = TRUE) %>%
    filter(daily_forcing_type=="ristos")

# SPU_dat <- read.csv("~/Documents/research_phd/data/OrchardInfo/LodgepoleSPUs.csv", header=TRUE, stringsAsFactors = FALSE) %>%
#    dplyr::select(SPU_Name, Orchard) #add provenance information
SPU_dat <- read.csv("~/phd/data/OrchardInfo/LodgepoleSPUs.csv", header=TRUE, stringsAsFactors = FALSE) %>%
dplyr::select(SPU_Name, Orchard)
 # SPU_dat <- read.csv("~/Documents/phd_sus/data/OrchardInfo/LodgepoleSPUs.csv", header=TRUE, stringsAsFactors = FALSE) %>%
 #   dplyr::select(SPU_Name, Orchard) #add provenance information

phendf <- phenology_data %>%
    na.omit()
phendf <- dplyr::left_join(phenology_data, SPU_dat) %>%
    unique()

view(dfSummary(phendf))
# summary(phendf)

```

```{r stanindexing}
#Create indexes that stan will like
stanindexer <- function(df) {
    df$CloneID <- group_indices(df, Clone)
    df$OrchardID <- group_indices(df, Orchard)
    df$ProvenanceID <- group_indices(df, SPU_Name)
    df$SiteID <- group_indices(df, Site)
    df$YearID <- group_indices(df, Year)
    df$Tree <- group_indices(df,TreeID)
    return(df)
}

fdf <- filter(phendf, Sex == "FEMALE")
fdf <- stanindexer(fdf)
mdf <- filter(phendf, Sex == "MALE")
mdf <- stanindexer(mdf)

#test
nrow(fdf) + nrow(mdf) == nrow(phendf)


```

```{r data}
view(dfSummary(fdf))
view(dfSummary(mdf))

ggplot(phendf, aes(x=Sex, y=forcing_accum, fill=as.factor(Phenophase_Derived))) +
    geom_violin() +
    scale_fill_viridis_d() + 
    ggtitle("range of heatsums at each stage")

```


Pollen shed almost always begins prior to or simultaneously with cone receptivity. Pollen shed finishes before the receptive period is over less than half the time and sometimes finishes after the receptivity period is done. 

```{r dataviz, fig.width=11, fig.height=9}
ggplot(phendf, aes(x=forcing_accum, color=Phenophase_Derived, linetype=Sex)) +
    stat_ecdf() +
    theme_bw(base_size=16) +
    facet_grid(SPU_Name ~ Site) +
    scale_color_viridis_d(direction =-1) +
    ggtitle("Phenophase accumulation as heatsum increases\n by Site and Provenance") +
    theme(legend.position = "bottom")

```

The order of development and the forcing accumulation required is much more consistent across sites than provenances, suggesting stronger site than provenance effects. The proportion of each phenophase at different forcing amounts is much more consistent within a site than within provenances, suggesting strong site effects/limited provenance effects.

```{r fig.width=11, fig.height=9}
ggplot(phendf, aes(x=forcing_accum, color=as.factor(Phenophase_Derived))) +
    geom_density() +
    theme_bw(base_size=16) +
    facet_grid(Site ~ SPU_Name, scales="free_y") +
    scale_color_viridis_d(direction=-1) +
    ggtitle("Phenophase proportion as heatsum increases\n by Site and Provenance") +
    theme(legend.position = "bottom")

ggplot(phendf, aes(x=forcing_accum, color=as.factor(Phenophase_Derived))) +
    geom_density() +
    theme_bw(base_size=16) +
    facet_grid(SPU_Name ~ Site, scales="free_y") +
    scale_color_viridis_d(direction=-1) +
    ggtitle("Phenophase proportion as heatsum increases\n by Site and Provenance") +
    theme(legend.position = "bottom")
```

<!--![Site x Provenance](../graphsforsally/phenophase_prop_sitexprov.png)
![Provenance x Site](../graphsforsally/phenophase_prop_provxsite.png) -->

As the developmental process for pollen shed and cone receptivity appears to be logistic (Sarvas 1972), I will use a logistic model. A logistic model has two parameters. $k$ affects the speed of transition and $h$ determines the time ("location") of transition. $k$ must be positive and between 0 and 1. $k$ near 0 is a slow transition. $k$ near one is a near instantaneous transition. $h$ is the inflection point of the curve, in our case, the point at which a given tree is 50% likely to have transitioned from state $s$ to state $s+1$

$$y = \frac{1}{1+e^{-k(x-h)}}$$

There are two transitions I need to model for each event - 
1) transitioning from not started to active and 
2) from active to completed. 

Since there are two transitions, I will use an ordered logistic model that describes the likelihood of being in each phenological state $s$ given a linear model $\eta$ and cutpoints $c$.

For $S=3$ categories

$$\small{\text{OrderedLogistic}(s|~\eta,c) = \left\{ \begin{array}{ll} 1 -
\text{logistic}(\eta - c_1)  &  \text{if } s = 1, \\[4pt]
\text{logistic}(\eta - c_1) - \text{logistic}(\eta - c_2)  &
\text{if } s=2, \text{and} \\[4pt] \text{logistic}(\eta -
c_3) - 0  &  \text{if } s = 3. \end{array} \right.}
$$
Where $\eta$ is a linear model with explanatory variable x - in our case, forcing units (*e.g.* heatsum), and $k$ slope
$$\eta = k x \\$$
This model is parameterized slightly differently than the logistic model above. In this model 

$$k=k \\
h_s=\frac{c_s}{k}\\$$

An ordered logistic model respects the ordering of the phenological states and generates two curves - one representing the "not-yet to active" transition and the other the "active to complete" transition. The transition from before not-yet to not-yet is not meaningful and $c_1$ is set to 0.

Adding intercept components to $\eta$ shifts the location and they are added to the cutpoints when calculating $h_s$. For example, adding a provenance effect to eta 

$$\eta=kx + \alpha_{provenance}$$
means that the location $h_s$ is calculated as

$$h_s = \frac{c_s+\alpha_{provenance}}{k}$$

In this example parameterization, cutpoints are not sex or population specific. $\alpha$ components in $\eta$ affect both transitions equally. So a provenance effect $\alpha_{provenance}$ will shift both the transition from state from 1 to 2 and from 2 to 3 by the same amount. Is this (biologically) correct?

Sarvas's experimental work on development in trees says that 

> the regression of the rate of progress of the active period on temperature is the same for all the genera, species, individual trees and the different parts of the active period investigated in this study. [@Sarvas1972]

His study included *Populus*, *Betula*, *Alnus* as well as *Picea abies*, *Pinus sylvestris*, and 2 *Larix* species.

The unit for the "rate of progress" is period units/hour where period units are 1/5 of the cycle interval that the active period of a given genotype progresses in 1 hour at a constant temperature of 10 degrees C.

So if it takes 100 hours to go from phenophase 1 to 2 at 10 degrees, then the period unit is 20 minutes.

This does not mean that everything should have the same slope ($k$). It does mean that I can use the same forcing units for everything.

I will parameterize this model with effects on k (slopes) from Sex and Provenance and effects on location (intercepts) from Sex, Site, Provenance, Clone, and Year.

### Important model assumptions
In a model where effects are included in eta, any effect influences both curves identically. That is, curves can be shifted to the left or right by an effect, but cannot be shifted in opposite directions.

I am making assumptions about the kinds of effects that are possible in what I choose to include on both slopes and intercepts.

In my current model

####Alternative parameterizations
##### Effects on each cutpoint
I could parameterize the model differently I think. For example, considering just the effects of sex and provenance: 

$$\eta = (k + k_{sex} + k_{provenance})x \\
c_1 = \alpha + \alpha_{sex} + \alpha_{provenance} \\
c_2 = \beta + \beta_{sex} + \beta_{provenance}
$$
This means making way more priors, but I think makes biological sense!  
In old versions of my model, whatever effects there are from provenance, clone, ramet, etc shift all $h_s$ by the same amount. 

This model would have at least double the number of parameters as the other parameterization and may be very difficult or impossible to fit. I did successfully create a model with different effects on both cutpoints, but wasn't able to make the model fit more than one group. This is a technical issue and not a theoretical one. 

##### Difference between cutpoints
Instead of modeling intercepts as part of $\eta$ or on each cutpoint individually, I could model the *difference* between cutpoints. This is my preferred approach, but I cannot make any versions of this with actual effects included work. I've asked for help [here](https://discourse.mc-stan.org/t/add-effects-to-difference-between-cutpoints-in-multilevel-ordered-logistic-model/8421).

I think this makes sense biologically. I'd estimate some main cutpoints and then the effects on the difference would determine the precise location. A positive male effect on the difference would mean that the curves are pushed apart. A negative male effect would mean the curves are pulled closer together. This is still symmetric, but could capture an effect like - males begin flowering at lower forcing units and stop flowering at higher forcing units than females.

### How to include effects of sex, provenance, etc.
The first question is whether to include the effect in the speed of transition $k$ or the locations.

### Male and female in same model?
I am not sure whether to include male and female strobili in the same model. Male and female strobili develop separately but as as part of the same elongating stem. 

If I include them in the same model, unless I do some really crazy parameterization, then I am assuming that clonal, provenance, tree, and site effects are the same across sexes. For example, a clone that has a lower threshold has a lower threshold for both males and females. 

I could do a test for this by running separate models or adding *a lot* of parameters.

The location must vary by sex. If there isn't a cutpoint component  for sex, then curves will be identical for males and females unless the $k$ is allowed to vary. Since $h_s$ depends on $k$ as well as the cutpoints, changes in $k$ can shift the location of the curve. 

Previous model runs have been letting $k$ vary by sex, but not the location. I believe that was a mistake. They could very easily have different $k$ and $h_s$

### Should the sex component have partial pooling?
No! Sex components should not be pooled across males and females. They're connected but separate and I believe they should be allowed to vary completely independently.

### What about pooling for other effects?
For clone, site, year, and provenance, I believe partial pooling is the right decision. No pooling will overfit and exaggerate effects, but ignoring the effects (total pooling) will ignore effects I'm testing for (provenance) or that undoubtedly exist (clone, site).

## So what does the model look like?

$$\begin{array}{rlr}

S_i & \sim \text{OrderedLogistic}(s |\eta_i, c_s)\\
\eta_i & = (k + k_{sex[i]} + k_{provenance[i]}) \times f_i + \alpha_i \\
\alpha_i &= \alpha_{sex[i]} + \alpha_{provenance[i]} + \alpha_{site[i]} + \alpha_{clone[i]} + \alpha_{year[i]} \\


&& \text{priors} \\
c_s &\sim \text{gamma}(7.5,1)
k &\sim \text{beta}(.5,5) & \text{slope priors}\\
k_{sex}, k_{provenance} &\sim \text{normal}(0, 0.1) \\
\alpha_{sex} &\sim \text{normal}(0, \sigma_{sex}) & \text{intercept priors}\\
\alpha_{provenance} &\sim \text{normal}(0, \sigma_{provenance}) \\
\alpha_{site} &\sim \text{normal}(0, \sigma_{site}) \\
\alpha_{clone} &\sim \text{normal}(0, \sigma_{clone}) \\
\alpha_{year} &\sim \text{normal}(0, \sigma_{tree}) \\
\\
&&\text{populations of varying effects} \\
\begin{bmatrix}
\alpha{sex} \\
\beta{sex}
\end{bmatrix} &\sim \text{MVNormal} \\


&& \text{hyperpriors}\\
\sigma_{sex} & \sim \text{exponential}(1.5) \\
\upsilon_{sex} &\sim \text{exponential}(1.5) \\
\\
\sigma_{provenance} &\sim \text{exponential}(1.5) \\
\upsilon_{provenance} &\sim \text{exponential}(1.5) \\
\\
\sigma_{site} &\sim \text{exponential}(1.5) \\
\upsilon_{site} &\sim \text{exponential}(1.5) \\
\\
\sigma_{clone} &\sim \text{exponential}(1.5) \\
\upsilon_{clone} &\sim \text{exponential}(1.5) \\
\\
\sigma_{ramet} &\sim \text{exponential}(1.5) \\
\upsilon_{ramet} &\sim \text{exponential}(1.5)
\end{array}$$


$f$ accumulated forcing units

## What about calculating the start, end, and length of the phenological period?

## Woah now let's calm down and do a simpler version. Maybe look back at an old workflow and try again.

## Fit a model to simulated data

Simulate data from an ordered logistic distribution with three states and forcing values from real data. 

```{r simulate simplest data}
cuts <- c(15,20)
beta <- 0.05
forcing <- runif(300, 175, 500)
eta <- beta * forcing 
state <- rordlogit(length(eta), phi = eta, a = cuts)
sim <- data.frame(forcing,state)
#sim$state <- group_indices(sim, state)
```

7 sites, 6 provenances, and 10 observations for each of 15 individuals at different forcing temperatures
```{r simulate_grouped_data}
# cutpoints <- c(0)
# cutpoints[2] <- abs(rnorm(1,5,2))
# cutpoints[3] <- abs(rnorm(1,20,2))
# #k <- rbeta(1,.5, 5)

nsite <- 7
nprov <- 6
nindiv <- 15
nobs <- 3
forcing <- runif(10, 175,500)
basecut <- c(15,20)
beta = 0.05
cut_site <- rnorm(n= nsite, mean=1, sd=1)
cut_prov <- rnorm(n= nprov, mean=-2, sd=1)

sites <- data.frame(site = 1:nsite, effect = cut_site)
provs <- data.frame(prov = 1:nprov, effect= cut_prov)

simu_prep <- tidyr::crossing(site = sites$site, prov = provs$prov, nobs, indiv = 1:nindiv, forcing) %>%
    dplyr::left_join(sites) %>% #add site and prov effects
    rename(site_effect = effect) %>%
    left_join(provs) %>%
    rename(prov_effect = effect) %>%
    mutate(group_effects = site_effect + prov_effect) 

simu <- simu_prep %>% # calculate cutpoints and eta
    # cutpoints
    mutate(cut1 = group_effects + basecut[1])  %>%
    mutate(cut2 = group_effects + basecut[2]) %>%
    # linear model eta
    mutate(eta = beta * forcing) 

#simulate states
for (i in 1:nrow(simu)) {
    simu$state[i] <- rordlogit(1, 
                               phi = simu$eta[i], 
                               a = c(simu$cut1[i], simu$cut2[i]))
    }
```

```{r visualize simulated_data}
hist(simu$state)
ggplot(simu, aes(x=forcing, y=state, color=prov)) +
    geom_jitter() +
    facet_wrap("site")
```

## Fit model to simulated data

```{r simulated fit, eval=FALSE}
#Use ulam to help draft the model
# sim <- select(sim, state, forcing)
# simfit <- ulam(
#     alist(
#         #likelihood
#         state ~ dordlogit(eta, cutpoints),
#         # model
#         eta <- beta * forcing,
#         cutpoints <- c(c1, c2),
#         c1 ~ half_normal(5, 3),
#         c2 ~ half_normal(20, 5),
#         # priors
#         beta ~ dbeta(.5,5)
#     ),
#     data=sim, chains=1, cores=1, iter=20
# )

# stancode(simfit)

# Write simulated data in a format stan can understand
# simplest data
K = length(unique(sim$state))
N = nrow(sim)
stan_rdump(c("N", "K", "forcing", "state"), "simulated_nogroups.Rdump")
simplesimdat <- read_rdump("simulated_nogroups.Rdump")

# 1 group data
K <- length(unique(sim$state))
N <- nrow(sim)
Ngroup = length(unique(sim$group))
stan_rdump(c("N", "K", "Ngroup", "forcing", "state", "group"), "simulated_data.Rdump")
simdat <- read_rdump("simulated_data.Rdump")

# Fit model to simulated data
simfit <- stan("cutpoints_difference.stan", 
               chains=5, cores=5, iter=2000, 
               data=simplesimdat)
              #control=list(adapt_delta=0.99))#, max_treedepth=11))

# Check diagnostics
util$check_all_diagnostics(simfit)
```

### Consider fit of model to simulated data
```{r precis simulated data fit, eval=FALSE}
precis(simfit, depth=2)
```

```{r extract fit, eval=FALSE}
simpost <- as.matrix(simfit)
pairs(simpost)
```


```{r plot real params vs posterior, eval=FALSE}
mcmc_areas(simpost, regex_pars = "cutpoints") + 
    geom_vline(xintercept = c(15,20))
mcmc_areas(simpost, pars="beta") +
    geom_vline(xintercept = 0.05)
```

If cutpoints prior is a single gamma distribution, cutpoints are not returned well. Neither is beta. Edited model so prior is on the difference between cutpoints rather than the cutpoints as a group. 

Also want to try 
- modeling cutpoints with separate linear models
- 

## Real data
```{r dataprep real, eval=FALSE}
N <- nrow(phendf)
K <- length(unique(phendf$Phenophase_Derived))
Nclone <- length(unique(phendf$CloneID))
Nprovenance <- length(unique(phendf$ProvenanceID))
Nsite <- length(unique(phendf$SiteID))
Nyear <- length(unique(phendf$YearID))


CloneID <- phendf$CloneID
ProvenanceID <- phendf$ProvenanceID
SiteID <- phendf$SiteID
YearID <- phendf$YearID

forcing <- phendf$forcing_accum
state <- phendf$Phenophase_Derived

L <- 1

stan_rdump(c("N", "K", "L", "Nsex", "Nclone", "Nprovenance", "Nsite", "SexID", "SiteID", "CloneID", "ProvenanceID", "forcing", "state"), "multilevel_phenology.Rdump")
standat <- read_rdump("multilevel_phenology.Rdump")
```

```{r fit model, eval=FALSE}


fit <- stan("multilevel_phenology.stan", 
               chains=5, cores=5, iter=3000, data=standat)


```

```{r save model, eval=FALSE}
saveRDS(fit, file = "multilevel_phenology.rds")
posterior_cp <- as.array(fit)
```

### Model version with correlation



```{r sex and prov with corr, eval=FALSE}

### sex, site, prov, clone, year
#generate stan code for a draft of the stan code
fit_full_draft <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- alphas + beta*forcing_accum,
        alphas <- a_sex[SexID] + a_site[SiteID] + a_prov[ProvenanceID] + a_clone[CloneID] + a_year[YearID],
        beta <- b + b_sex[SexID] + b_prov[ProvenanceID],
        #priors
        b ~ dbeta(.5,5),
        kappa ~ dnorm(10,2), #change to gamma in real model
        a_site[SiteID] ~ dnorm(0,1),
        a_clone[CloneID] ~ dnorm(0,1),
        a_year[YearID] ~ dnorm(0,1),
        #sex
        c(a_sex, b_sex)[SexID] ~ multi_normal(c(as, bs), Rhos, sigma_sex),
        as ~ dnorm(0,1),
        bs ~ dnorm(0, 0.1),
        sigma_sex ~ exponential(1),
        #provenance
        c(a_prov, b_prov)[ProvenanceID] ~ multi_normal(c(ap, bp), Rhop, sigma_prov),
        ap ~ dnorm(0,1),
        bp ~ dnorm(0, 0.1),
        sigma_prov ~ exponential(1),
        Rhos ~ lkj_corr(2),
        Rhop ~ lkj_corr(2)
    ),
    data=phendf, sample=FALSE, declare_all_data= FALSE, iter = 10
)
stancode(fit_full_draft)
```


```{r fit full model, eval=FALSE}

fitful <- stan("../correlation.stan", 
               chains=8, cores=8, warmup = 1000, iter=1200, 

```
```{r save model output, eval=FALSE}
parsum <- precis(fitful, depth = 2)
saveRDS(fitful, file = "2019-04-14_correlation.rds")
posterior_cp <- as.array(fit)

```
```{r with pooling, eval=FALSE}
#generate stan code for a draft of the stan code
fit_full_draft <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- alphas + beta*forcing_accum,
        alphas <- a_sex[SexID] + a_site[SiteID] + a_prov[ProvenanceID] + a_clone[CloneID] + a_year[YearID],
        beta <- b + b_sex[SexID] + b_prov[ProvenanceID],
        #priors
        b ~ dbeta(.5,5),
        kappa ~ dnorm(10,2), # change to gamma in stan
        a_site[SiteID] ~ dnorm(0,site_sigma),
        a_clone[CloneID] ~ dnorm(0,clone_sigma),
        a_year[YearID] ~ dnorm(0,year_sigma),
        #sex
        c(a_sex, b_sex)[SexID] ~ multi_normal(c(as, bs), Rhos, sigma_sex),
        as ~ dnorm(0,1),
        bs ~ dnorm(0, 0.1),
        sigma_sex ~ exponential(1),
        #provenance
        c(a_prov, b_prov)[ProvenanceID] ~ multi_normal(c(ap, bp), Rhop, sigma_prov),
        ap ~ dnorm(0,1),
        bp ~ dnorm(0, 0.1),
        sigma_prov ~ exponential(1),
        #pop varying effects
        Rhos ~ lkj_corr(2),
        Rhop ~ lkj_corr(2),
        # hyperpriors
        site_sigma ~ exponential(2),
        clone_sigma ~ exponential(2),
        year_sigma ~ exponential(2)
    ),
    data=phendf, sample=FALSE, declare_all_data= FALSE
)
stancode(fit_full_draft)
```
```{r fit correlation with pooling, eval=FALSE}
fitfulpool <- stan("../correlation_with_pooling.stan", 
               chains=8, cores=8, warmup = 1000, iter=1300, 
               data=phendf)
```

```{r save pooling model output}
#parsumpool <- precis(fitfulpool, depth = 2)
#saveRDS(fitfulpool, file = "2019-04-15_correlation_with_pooling.rds")

fitfulpool.stan <- readRDS("../2019-04-15_correlaton_with_pooling.rds")
posteriorpool <- as.array(fitfulpool.stan)
parsumpool <- precis(fitfulpool.stan, depth=2)
postext <- extract.samples(fitfulpool.stan)

```
```{r plot some model}
dens( postext$Rhop[,1,2] )
dens( postext$Rhos[,1,2] )
```
Negative correlation between slopes and intercepts for provenance.
Unclear correlatoin between slopes and intercepts for sex. This doesn't look well fit. I think I might need separate models for each sex.

```{r pooling}
# compute unpooled estimates directly from data
ap_unpooled <- sapply( 1:length(unique(phendf$ProvenanceID)) ,
        function(i) mean(phendf$forcing_accum[phendf$ProvenanceID==i]) )
#bp_unpooled <- sapply( 1:length(unique(phendf$ProvenanceID)) ,
      #  function(i) mean(phendf$forcing_accum[phendf$ProvenanceID==i])) - ap_unpooled
# extract posterior means of partially pooled estimates

a_prov <- apply( postext$a_prov , 2 , mean )
b_prov <- apply( postext$b_prov , 2 , mean )

# plot both and connect with lines
plot( ap_unpooled * b_prov, b_prov , xlab="intercept" , ylab="slope" ,
    pch=16 , col=rangi2 , ylim=c( min(b_prov)-0.1 , max(b_prov)+0.1 ) ,
    xlim=c( min(a_prov)-0.1 , max(a_prov)+0.1 ) )
points( a_prov , b_prov , pch=1 )
#for ( i in 1:N_cafes ) lines( c(a1[i],a2[i]) , c(b1[i],b2[i]) )

# compute posterior mean bivariate Gaussian
Mu_est <- c( mean(postext$ap) , mean(postext$bp) )
rho_est <- mean( postext$Rhop[,1,2] )
sa_est <- mean( postext$sigma_prov[,1] )
sb_est <- mean( postext$sigma_prov[,2] )
cov_ab <- sa_est*sb_est*rho_est
Sigma_est <- matrix( c(sa_est^2,cov_ab,cov_ab,sb_est^2) , ncol=2 )
# draw contours
library(ellipse)
for ( l in c(0.1,0.3,0.5,0.8,0.99) )
    lines(ellipse(Sigma_est,centre=Mu_est,level=l),
        col=col.alpha("black",0.2))
```

```{r}
mcmc_intervals(posteriorpool, regex_pars = c("a_prov", "a_site", "a_year", "a_sex"))
mcmc_intervals(posteriorpool, regex_pars = c("b_prov", "b_site", "b_year", "b_sex", "b"))

mcmc_intervals(posteriorpool, regex_pars = "b_prov") + ggtitle("slope effect provenance")
mcmc_intervals(posteriorpool, regex_pars = "a_prov") + ggtitle("intercept effect provenance")

# betas

betas <- postext$b + postext$b_prov[,1] + postext$b_sex
mcmc_intervals(betas)

# prov threshold effect
h50p1 <- (postext$kappa[,1] + postext$a_prov)/postext$b_prov
colnames(h50p1) <- unique(phen$SPU_Name)

h50p2 <- (postext$kappa[,2] + postext$a_prov)/postext$b_prov
colnames(h50p2) <- unique(phen$SPU_Name)

mcmc_intervals(h50p1)
mcmc_intervals(h50p2)

#sex threshold effects
h50sex1 <- (postext$kappa[,1] + postext$a_sex)/postext$b_sex
colnames(h50sex1) <- unique(phen$Sex)

h50sex2 <- (postext$kappa[,2] + postext$a_sex)/postext$b_sex
colnames(h50sex2) <- unique(phen$Sex)

mcmc_intervals(h50sex1)
mcmc_intervals(h50sex2)


```

### Separate male and female models with no correlation


```{r ulam draft, eval=FALSE}

stancleaner <- function(df) {
    df <- dplyr::select(df, -Site, -SPU_Name, -Sex, -TreeID, -Phenophase, -Date, -Clone, -daily_forcing_type)
    return(df)
}

fdf <- stancleaner(fdf)
mdf <- stancleaner(mdf)

fit_draft <- ulam(
    alist(
        Phenophase_Derived ~ dordlogit(phi, kappa),
        phi <- a_prov[ProvenanceID] + a_site[SiteID] + a_year[YearID] + a_clone[CloneID] + beta*forcing_accum,
        #priors
        beta ~ dbeta(.5,5),
        kappa ~ dnorm(10,2), # change to gamma in stan
        a_prov[ProvenanceID] ~ dnorm(0, prov_sigma),
        a_site[SiteID] ~ dnorm(0,site_sigma),
        a_year[YearID] ~ dnorm(0,year_sigma),
        a_clone[CloneID] ~ dnorm(0,clone_sigma),
        # hyperpriors
        prov_sigma ~ exponential(1.5),
        site_sigma ~ exponential(1.5),
        year_sigma ~ exponential(1.5),
        clone_sigma ~ exponential(1.5)
    ),
    data=fdf, sample=FALSE, declare_all_data = FALSE) #change data depending on male or female model

stancode(fit_draft)
```

#### female
```{r fit female, eval=FALSE}
fitfem <- stan("../female_intercept_only.stan", 
               chains=8, cores=8, warmup = 1100, iter=1300, 
               data=fdf)

femsum <- precis(fitfem, depth = 2)
saveRDS(fitfem, file = "2019-04-16_fem_intercept_only.rds")

fitfem.stan <- readRDS(2019-04-16_fem_intercept_only.rds")
```


#### male
```{r fit male, eval=FALSE}

fitm <- stan("male_intercept_only.stan", 
               chains=8, cores=8, warmup = 1100, iter=1300, 
               data=mdf)

msum <- precis(fitfem, depth = 2)
saveRDS(fitm, file = "2019-04-17_male_intercept_only.rds")

fitm.stan <- readRDS(2019-04-16_fem_intercept_only.rds")

```


